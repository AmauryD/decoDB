import { DenoDB } from "../../deps.ts";
import { getMetadataStorage } from "../../mod.ts";

export function buildRelationships(
  entities: (typeof DenoDB.Model)[],
) {
  const metadata = getMetadataStorage();
  const generatedPivots: (typeof DenoDB.Model)[] = [];

  for (const EntityModel of entities) {
    const entityMeta = metadata.entities.find((e) => e.target === EntityModel);

    if (!entityMeta) {
      throw new Error(
        `No metadata found for ${EntityModel}, please decorate with @Entity()`,
      );
    }

    const relationships = metadata.relations.filter((e) =>
      e.target === EntityModel
    ) ?? [];

    for (
      const { type, relationTarget, property, inverseKey, options }
        of relationships
    ) {
      const RelationTarget = relationTarget();
      let relFunction:
        | ((
          this: typeof EntityModel,
        ) => Promise<unknown>)
        | undefined;
      let inverseRelFunction:
        | ((
          this: typeof RelationTarget,
        ) => Promise<unknown>)
        | undefined;

      console.log(
        type,
        "register",
        EntityModel.name,
        "with",
        property,
        "on",
        RelationTarget.name,
        "with",
        inverseKey,
      );
      if (type === "belongs-to") {
        DenoDB.Relationships.belongsTo(EntityModel, RelationTarget, options);
        relFunction = function (this: typeof EntityModel) {
          console.log(
            EntityModel.name,
            "has-one",
            RelationTarget.name,
            property,
            inverseKey,
          );
          return this.hasOne(RelationTarget);
        };
        inverseRelFunction = function (this: typeof RelationTarget) {
          console.log(
            RelationTarget.name,
            "has-many",
            EntityModel.name,
            property,
            inverseKey,
          );
          return this.hasMany(EntityModel);
        };
      } else if (type === "many-to-many") {
        const PivotTable = DenoDB.Relationships.manyToMany(
          EntityModel,
          RelationTarget,
          options,
        );
        // add pivot table (generated by many to many)
        generatedPivots.push(PivotTable);
        relFunction = function (this: typeof EntityModel) {
          console.log(
            EntityModel.name,
            "has-many",
            RelationTarget.name,
            property,
            inverseKey,
          );
          return this.hasMany(RelationTarget);
        };
        inverseRelFunction = function (this: typeof RelationTarget) {
          console.log(
            RelationTarget.name,
            "has-many",
            EntityModel.name,
            property,
            inverseKey,
          );
          return this.hasMany(EntityModel);
        };
      } else if (type === "one-to-one") {
        DenoDB.Relationships.oneToOne(EntityModel, RelationTarget, options);
        relFunction = function (this: typeof EntityModel) {
          console.log(
            EntityModel.name,
            "has-one",
            RelationTarget.name,
            property,
            inverseKey,
          );
          return this.hasOne(RelationTarget);
        };
        inverseRelFunction = function (this: typeof RelationTarget) {
          console.log(
            RelationTarget.name,
            "has-one",
            EntityModel.name,
            property,
            inverseKey,
          );
          return this.hasOne(EntityModel);
        };
      }

      if (relFunction && inverseRelFunction) {
        if (!Object.hasOwn(RelationTarget, inverseKey)) {
          Object.defineProperty(RelationTarget, inverseKey, {
            value: inverseRelFunction,
          });
        }
        if (!Object.hasOwn(EntityModel, property)) {
          Object.defineProperty(EntityModel, property, {
            value: relFunction,
          });
        }
      }
    }
  }
  return generatedPivots.concat(entities);
}
